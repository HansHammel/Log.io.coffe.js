// Generated by CoffeeScript 1.11.1

/* Log.io Log Harvester

Watches local files and sends new log message to server via TCP.

 * Sample configuration:
config =
  nodeName: 'my_server01'
  logStreams:
    web_server: [
      '/var/log/nginx/access.log',
      '/var/log/nginx/error.log'
    ],
  server:
    host: '0.0.0.0',
    port: 28777

 * Sends the following TCP messages to the server:
"+node|my_server01|web_server\r\n"
"+bind|node|my_server01\r\n"
"+log|web_server|my_server01|info|this is log messages\r\n"

 * Usage:
harvester = new LogHarvester config
harvester.run()
 */

(function() {
  var LogHarvester, LogStream, events, fs, net, winston,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  fs = require('fs');

  net = require('net');

  events = require('events');

  winston = require('winston');


  /*
  LogStream is a group of local files paths.  It watches each file for
  changes, extracts new log messages, and emits 'new_log' events.
   */

  LogStream = (function(superClass) {
    extend(LogStream, superClass);

    function LogStream(name, paths1, _log) {
      this.name = name;
      this.paths = paths1;
      this._log = _log;
    }

    LogStream.prototype.watch = function() {
      var i, len, path, ref;
      this._log.info("Starting log stream: '" + this.name + "'");
      ref = this.paths;
      for (i = 0, len = ref.length; i < len; i++) {
        path = ref[i];
        this._watchFile(path);
      }
      return this;
    };

    LogStream.prototype._watchFile = function(path) {
      var currSize, watcher;
      if (!fs.existsSync(path)) {
        this._log.error("File doesn't exist: '" + path + "'");
        setTimeout(((function(_this) {
          return function() {
            return _this._watchFile(path);
          };
        })(this)), 1000);
        return;
      }
      this._log.info("Watching file: '" + path + "'");
      currSize = fs.statSync(path).size;
      return watcher = fs.watch(path, (function(_this) {
        return function(event, filename) {
          if (event === 'rename') {
            watcher.close();
            _this._watchFile(path);
          }
          if (event === 'change') {
            return fs.stat(path, function(err, stat) {
              _this._readNewLogs(path, stat.size, currSize);
              return currSize = stat.size;
            });
          }
        };
      })(this));
    };

    LogStream.prototype._readNewLogs = function(path, curr, prev) {
      var rstream;
      if (curr < prev) {
        return;
      }
      rstream = fs.createReadStream(path, {
        encoding: 'utf8',
        start: prev,
        end: curr
      });
      return rstream.on('data', (function(_this) {
        return function(data) {
          var i, len, line, lines, results;
          lines = data.split("\n");
          results = [];
          for (i = 0, len = lines.length; i < len; i++) {
            line = lines[i];
            if (line) {
              results.push(_this.emit('new_log', line));
            }
          }
          return results;
        };
      })(this));
    };

    return LogStream;

  })(events.EventEmitter);


  /*
  LogHarvester creates LogStreams and opens a persistent TCP connection to the server.
  
  On startup it announces itself as Node with Stream associations.
  Log messages are sent to the server via string-delimited TCP messages
   */

  LogHarvester = (function() {
    function LogHarvester(config) {
      var paths, ref, ref1, s;
      this.nodeName = config.nodeName, this.server = config.server;
      this.delim = (ref = config.delimiter) != null ? ref : '\r\n';
      this._log = (ref1 = config.logging) != null ? ref1 : winston;
      this.logStreams = (function() {
        var ref2, results;
        ref2 = config.logStreams;
        results = [];
        for (s in ref2) {
          paths = ref2[s];
          results.push(new LogStream(s, paths, this._log));
        }
        return results;
      }).call(this);
    }

    LogHarvester.prototype.run = function() {
      this._connect();
      return this.logStreams.forEach((function(_this) {
        return function(stream) {
          return stream.watch().on('new_log', function(msg) {
            if (_this._connected) {
              return _this._sendLog(stream, msg);
            }
          });
        };
      })(this));
    };

    LogHarvester.prototype._connect = function() {
      this.socket = new net.Socket;
      this.socket.on('error', (function(_this) {
        return function(error) {
          _this._connected = false;
          _this._log.error("Unable to connect server, trying again...");
          return setTimeout((function() {
            return _this._connect();
          }), 2000);
        };
      })(this));
      this._log.info("Connecting to server...");
      return this.socket.connect(this.server.port, this.server.host, (function(_this) {
        return function() {
          _this._connected = true;
          return _this._announce();
        };
      })(this));
    };

    LogHarvester.prototype._sendLog = function(stream, msg) {
      this._log.debug("Sending log: (" + stream.name + ") " + msg);
      return this._send('+log', stream.name, this.nodeName, 'info', msg);
    };

    LogHarvester.prototype._announce = function() {
      var l, snames;
      snames = ((function() {
        var i, len, ref, results;
        ref = this.logStreams;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          l = ref[i];
          results.push(l.name);
        }
        return results;
      }).call(this)).join(",");
      this._log.info("Announcing: " + this.nodeName + " (" + snames + ")");
      this._send('+node', this.nodeName, snames);
      return this._send('+bind', 'node', this.nodeName);
    };

    LogHarvester.prototype._send = function() {
      var args, mtype;
      mtype = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      return this.socket.write(mtype + "|" + (args.join('|')) + this.delim);
    };

    return LogHarvester;

  })();

  exports.LogHarvester = LogHarvester;

}).call(this);
